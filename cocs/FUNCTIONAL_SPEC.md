# COCS 功能规格说明文档

## 1. 项目概述

### 1.1 项目名称
COCS - 咸鱼AI客服系统 (Xianyu Customer Service AI System)

### 1.2 项目目标
构建一个基于浏览器自动化和AI大模型的智能客服系统，实现咸鱼平台客户消息的自动监控、智能回复和人工介入通知，提高客服效率并保证服务质量。

### 1.3 核心价值
- **降低人力成本**：自动处理常见客户咨询，减少人工客服工作量
- **提升响应速度**：7x24小时实时监控和快速响应客户消息
- **保证服务质量**：通过置信度评估确保回复准确性，低置信度自动转人工
- **数据持久化**：完整记录消息处理历史，支持系统重启后恢复

---

## 2. 功能需求

### 2.1 核心功能

#### 2.1.1 消息监控
- **实时监控**：持续监控咸鱼聊天界面的新消息
- **多联系人支持**：同时监控多个客户联系人
- **消息去重**：基于消息内容和发送者的哈希机制，避免重复处理同一消息
- **持久化存储**：记录已处理消息，支持系统重启后继续工作

#### 2.1.2 智能回复
- **AI生成回复**：基于聊天历史和上下文生成智能回复
- **多AI模型支持**：
  - Dify AI平台集成
  - 阿里云Qwen模型集成
  - 可扩展其他AI模型
- **上下文理解**：获取最近10条聊天记录作为上下文

#### 2.1.3 置信度评估
- **自动评估机制**：
  - 置信度 ≥ 0.7：自动发送AI回复
  - 置信度 < 0.7：通知人工介入
- **敏感词检测**：识别敏感关键词，自动降低置信度
- **人工标记**：AI可主动标记需要人工处理的场景

#### 2.1.4 人工介入通知
- **多渠道通知**：
  - 企业微信机器人通知
  - 邮件通知
- **通知内容**：
  - 客户信息
  - 消息内容
  - AI建议回复
  - 置信度评分
  - 需要人工介入的原因

### 2.2 辅助功能

#### 2.2.1 HTTP API接口
- `POST /messages` - 接收新消息
- `GET /messages/{chat_id}` - 获取聊天记录
- `GET /chats` - 获取所有聊天会话
- `POST /messages/{message_id}/response` - 发送AI回复

#### 2.2.2 系统管理
- **登录管理**：支持手动登录咸鱼账号
- **状态监控**：实时显示系统运行状态
- **日志记录**：完整记录系统运行和消息处理过程
- **错误恢复**：浏览器异常自动重连

---

## 3. 用户场景

### 3.1 场景1：常规客户咨询
**用户故事**：客户询问商品价格、库存等常见问题

**流程**：
1. 客户发送消息："这个还有吗？"
2. 系统检测到新消息
3. AI分析聊天历史和商品信息
4. 生成回复："您好，该商品目前有货，价格是XXX元"
5. 置信度评估 ≥ 0.7
6. 自动发送回复给客户

### 3.2 场景2：复杂问题需人工介入
**用户故事**：客户咨询退换货、投诉等复杂问题

**流程**：
1. 客户发送消息："我要退货，这个质量有问题"
2. 系统检测到新消息
3. AI分析消息内容
4. 识别到"退货"、"质量问题"等敏感词
5. 置信度评估 < 0.7 或主动标记需人工处理
6. 发送微信/邮件通知客服人员
7. 人工客服介入处理

### 3.3 场景3：系统重启后恢复
**用户故事**：系统维护重启后继续处理新消息

**流程**：
1. 系统重启前已处理消息："你好"（已保存哈希）
2. 系统重启
3. 加载持久化数据，恢复已处理消息记录
4. 检测到新消息："明天发货吗？"
5. 对比消息哈希，确认是新消息
6. 继续正常处理流程

### 3.4 场景4：消息去重机制
**用户故事**：避免对同一消息重复回复

**流程**：
1. 客户发送消息："你好"
2. 系统提取消息，生成哈希：`hash("你好" + "客户A") = abc123`
3. AI处理并回复
4. 保存哈希到数据库：`{"客户A": "abc123"}`
5. 下次循环再次检测到该消息
6. 提取消息，生成相同哈希：`abc123`
7. 对比数据库记录，发现已处理
8. 跳过该消息，继续检测其他联系人

---

## 4. 业务流程

### 4.1 系统启动流程

```
1. 启动程序
   ├── 加载配置文件
   ├── 初始化日志系统
   └── 初始化各个服务模块
       ├── 浏览器服务
       ├── AI服务
       ├── 消息服务
       └── 通知服务

2. 启动浏览器
   ├── 打开Chrome浏览器
   ├── 访问咸鱼聊天页面
   └── 等待用户手动登录

3. 开始监控
   ├── 加载持久化数据（已处理消息记录）
   └── 进入消息监控循环
```

### 4.2 消息监控流程

```
循环监控 {
    1. 检查有新消息标记的联系人
       └── 如果没有 → 等待5秒 → 继续循环

    2. 遍历有新消息标记的联系人
       ├── 进入联系人聊天界面
       ├── 提取聊天消息（最多50条）
       └── 查找真正的新消息

    3. 消息去重判断（优化后）
       ├── 直接获取最新的接收消息
       ├── 生成消息哈希：hash(消息内容 + 发送者)
       ├── 对比数据库中该联系人的最后消息哈希
       └── 如果哈希不同 → 确认为新消息；如果相同 → 跳过

    4. 处理新消息
       ├── 保存新消息哈希到数据库
       ├── 调用消息处理服务
       └── 返回继续监控
}
```

### 4.3 消息处理流程

```
处理消息 {
    1. 创建消息对象
       ├── 生成消息ID
       ├── 创建聊天会话ID
       └── 保存消息到内存

    2. AI处理
       ├── 获取聊天历史（最近10条）
       ├── 调用AI服务生成回复
       └── 接收AI响应
           ├── 回复内容
           ├── 置信度评分
           └── 是否需要人工介入标记

    3. 置信度判断
       ├── 如果置信度 ≥ 0.7 且不需要人工
       │   └── 自动发送AI回复到咸鱼
       └── 如果置信度 < 0.7 或需要人工
           └── 发送通知给客服人员
               ├── 企业微信通知
               └── 邮件通知
}
```

### 4.4 消息去重详细机制

#### 4.4.1 哈希生成策略
```python
# 消息哈希生成（browser/data_persistence.py:62-67）
def generate_message_hash(message: Dict) -> str:
    """
    只使用消息内容和发送者生成唯一标识
    不使用timestamp，因为每次提取时timestamp都会变化
    """
    content = f"{message.get('text', '')}{message.get('sender', '')}"
    return hashlib.md5(content.encode('utf-8')).hexdigest()
```

**设计原则**：
- ✅ **包含字段**：消息文本 + 发送者名称
- ❌ **排除字段**：时间戳（动态生成，不稳定）
- 🎯 **唯一性保证**：同一发送者的相同文本内容产生相同哈希

#### 4.4.2 去重判断逻辑（已优化）

```python
# 查找新消息（browser/data_persistence.py:69-116）
def find_new_message_for_contact(contact_name: str, messages: list) -> Dict:
    """
    简化逻辑：
    1. 只处理有新消息标记的联系人
    2. 直接获取该联系人最新的接收消息
    3. 对比哈希值，如果不同则为新消息
    """
```

**优化后的判断流程**（2024-10-08更新）：
```
输入：联系人名称 + 当前消息列表（只有标记有新消息的联系人才会调用）

1. 获取最新的接收消息
   latest_message = get_latest_received_message(messages)
   # 从后往前找第一条接收消息

2. 获取已保存的哈希
   last_hash = database.get("联系人A")

3. 计算当前最新消息的哈希
   current_hash = generate_hash(latest_message)

4. 对比哈希值
   if current_hash == last_hash:
       return None  # 已处理，跳过
   else:
       return latest_message  # 新消息，处理
```

**核心优化点**：
- ✅ **只关注最新消息**：不遍历历史消息，直接获取最新接收消息
- ✅ **严格遵循新消息标记**：只有标记有新消息的联系人才会进入此逻辑
- ✅ **算法复杂度优化**：从O(n)降为O(1)
- ✅ **逻辑更清晰**：直接对比最新消息哈希，避免中间状态

**优化前后对比**：

| 维度 | 优化前 | 优化后 |
|------|--------|--------|
| **处理方式** | 遍历所有消息，找第一条新消息 | 直接获取最新消息 |
| **时间复杂度** | O(n) | O(1) |
| **可能问题** | 可能返回中间历史消息 | 只返回最新消息 |
| **代码行数** | ~35行 | ~35行（逻辑简化） |

#### 4.4.3 持久化存储
```json
// goofish_data/last_messages.json
{
  "联系人A": "abc123def456...",  // 最后处理消息的MD5哈希
  "联系人B": "789xyz012uvw...",
  ...
}
```

**存储时机**：
- 每次处理完新消息后立即保存
- 保证系统重启后能恢复状态

#### 4.4.4 修复前的问题
❌ **旧实现（已修复）**：
```python
# 错误：包含了动态变化的timestamp
content = f"{text}{timestamp}{sender}"
```

**问题表现**：
- 每次提取消息时，`dom_parser`使用`new Date()`生成当前时间
- 同一条消息每次的timestamp不同
- 导致哈希值每次都不同
- 系统认为总是"新消息"
- 陷入无限循环

✅ **新实现（已修复）**：
```python
# 正确：只使用稳定的内容
content = f"{text}{sender}"
```

**修复效果**：
- 消息哈希值稳定
- 正确识别已处理消息
- 避免重复处理
- 系统正常运行

---

## 5. 数据模型

### 5.1 消息对象 (Message)
```python
{
    "id": "uuid",                    # 消息唯一ID
    "text": "消息内容",              # 消息文本
    "sender": "客户名称",            # 发送者
    "timestamp": "2024-01-01T10:00:00Z",  # 时间戳
    "chat_id": "chat_客户名称_20240101",  # 聊天会话ID
    "message_type": "received",      # 消息类型：received/sent
    "processed": false,              # 是否已处理
    "ai_response": "AI回复内容",     # AI生成的回复
    "confidence_score": 0.85,        # 置信度评分
    "require_human": false           # 是否需要人工介入
}
```

### 5.2 聊天会话 (ChatSession)
```python
{
    "chat_id": "chat_客户A_20240101",  # 会话ID
    "contact_name": "客户A",           # 联系人名称
    "last_message_time": "2024-01-01T10:00:00Z",  # 最后消息时间
    "message_count": 15,               # 消息数量
    "active": true                     # 是否活跃
}
```

### 5.3 持久化数据
```json
// last_messages.json - 已处理消息记录
{
    "联系人名称": "消息哈希值"
}

// contact_states.json - 联系人状态（预留）
{
    "联系人名称": {
        "last_active": "2024-01-01T10:00:00Z",
        "notes": "备注信息"
    }
}
```

---

## 6. 配置说明

### 6.1 AI服务配置
```bash
# Dify模式
AI_SERVICE_TYPE=dify
DIFY_API_URL=https://api.dify.ai
DIFY_API_KEY=your_api_key

# Qwen模式
AI_SERVICE_TYPE=qwen
QWEN_API_KEY=your_api_key
QWEN_MODEL_NAME=qwen-turbo
```

### 6.2 通知配置
```bash
# 企业微信
WECHAT_WEBHOOK_URL=https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxx

# 邮件
EMAIL_SMTP_SERVER=smtp.gmail.com
EMAIL_SMTP_PORT=587
EMAIL_USERNAME=your_email@gmail.com
EMAIL_PASSWORD=your_password
EMAIL_RECIPIENTS=admin@company.com,support@company.com
```

### 6.3 系统配置
```bash
# 浏览器
BROWSER_HEADLESS=false           # 是否无头模式
BROWSER_LOGIN_TIMEOUT=300000     # 登录超时（毫秒）

# 消息监控
MESSAGE_POLL_INTERVAL=5          # 轮询间隔（秒）
MESSAGE_BATCH_SIZE=50            # 每次提取消息数量

# 数据存储
DATA_DIR=./goofish_data          # 数据存储目录
```

---

## 7. 性能指标

### 7.1 响应性能
- **消息检测延迟**：≤ 5秒
- **AI回复生成**：≤ 10秒
- **消息发送延迟**：≤ 2秒

### 7.2 可靠性
- **消息处理准确率**：99.9%（不重复、不遗漏）
- **系统可用性**：99%（7x24运行）
- **数据持久化**：100%（消息记录不丢失）

### 7.3 扩展性
- **并发联系人**：支持100+联系人同时监控
- **消息吞吐量**：≥ 100条/分钟
- **存储空间**：按需扩展

---

## 8. 安全考虑

### 8.1 数据安全
- **敏感信息**：API密钥存储在环境变量，不提交代码库
- **消息加密**：本地存储的消息数据建议加密（待实现）
- **访问控制**：API接口需要身份验证（待实现）

### 8.2 系统安全
- **错误处理**：完善的异常捕获和恢复机制
- **日志脱敏**：敏感信息不记录到日志
- **限流保护**：防止API滥用（待实现）

---

## 9. 未来扩展

### 9.1 短期规划
- [ ] 支持更多AI模型（ChatGPT、Claude等）
- [ ] Web管理界面
- [ ] 消息数据可视化统计
- [ ] 批量消息处理

### 9.2 长期规划
- [ ] 多平台支持（淘宝、拼多多等）
- [ ] 智能学习优化（基于历史反馈）
- [ ] 客户画像分析
- [ ] 自动化营销功能

---

## 10. 附录

### 10.1 术语表
- **联系人**：咸鱼平台上的买家或卖家
- **消息哈希**：基于消息内容和发送者生成的唯一标识
- **置信度**：AI对生成回复准确性的评估分数（0-1）
- **串行处理**：按顺序逐条处理消息，确保不重复不遗漏

### 10.2 参考文档
- [技术架构规格说明](./TECHNICAL_SPEC.md)
- [函数调用流程图](./COCS_Function_Call_Flow.md)
- [串行处理说明](./browser/README_serial_processing.md)
